{"info":{"author":"LSEG","author_email":"datastreamapi@lseg.com","bugtrack_url":null,"classifiers":[],"description":"A python package for retrieving Datastream content, our historical financial database with over 35 million individual instruments\r\nor indicators across all major asset classes, including over 19 million active economic indicators. It features 120 years of data,\r\nacross 175 countries – the information you need to interpret market trends, economic cycles, and the impact of world events.\r\n\r\nData spans bond indices, bonds, commodities, convertibles, credit default swaps, derivatives, economics, energy, equities, equity\r\nindices, ESG, estimates, exchange rates, fixed income, funds, fundamentals, interest rates, and investment trusts. Unique content\r\nincludes I/B/E/S Estimates, Worldscope Fundamentals, point-in-time data, and Reuters Polls.\r\n\r\nAlongside the content, sit a set of powerful analytical tools for exploring relationships between different asset types, with a library of customizable analytical functions.\r\n\r\nIn-house timeseries can also be uploaded using the package to comingle with Datastream maintained datasets, use with these analytical\r\ntools and displayed in Datastream’s flexible charting facilities in Microsoft Office. \r\n\r\n\r\n# Available in this version \r\n\r\nThis release supports the following features:\r\n\r\n* A DataClient for retrieval of static and timeseries data.\r\n* A TimeserieClient for creating and managing your custom timeseries data.\r\n* An EconomicFilters client for creating and managing custom filters for analysing changes to economics data.\r\n\r\n\r\n# Dependencies\r\n\r\nThis package has a dependency on the pandas, requests and ssl packages.\r\n\r\n\r\n# Prerequisites\r\n\r\nYou need to have an account to access Datastream content and these credentials need to be permissioned to access our API service.\r\n\r\nIf you do not have an account, please request Datastream product details [here](https://www.lseg.com/en/data-analytics/products/datastream-macroeconomic-analysis/). If you do have an account, please contact your local LSEG representative to discuss access to the web API service.\r\n\r\nIn addition to the basic access, you need additional permissions to be able to create and manage custsom timeseries and economic filters. Again, contact your customer representative.\r\n\r\n\r\n# Upgrading from DatastreamPy-1.0.x packages to DatastreamPy-2.0.x\r\n\r\nDatastreamPy version 2.0 modifies the method of invoking the Datastream client. Prior to version 2.0 you needed to supply your credentials in the\r\nclient constructor. Whilst you can still supply your credentials in the new constructor, version 2.0 supports client credentials being read directly from a\r\nconfiguration file. Note, the client constructor has also been renamed as part of the additional support for user created timeseries and economic filters.\r\n\r\n```\r\n# In earlier versions (1.0.x), you need to supply your credentials.\r\nds = dsweb.Datastream(username='YourID', password='YourPwd')\r\n\r\n# In version 2.0.x, the client has been renamed from Datastream to DataClient and the credentials can be supplied from a configuration file\r\nds = dsweb.DataClient('Config.ini')\r\n# or supplied directly as before.\r\nds = dsweb.DataClient(None, 'YourID', 'YourPwd')\r\n# Note credentials supplied in the constructor will override any credentials set in the configuration file if also provided\r\nds = dsweb.DataClient('Config.ini', 'YourIdOverride', 'YourPwdOverride')\r\n```\r\n\r\nThe configuration file has the following sections. Note, the path setting should only be modified for private network configurations (Delivery Direct)\r\nunder the advice of your Datastream representative. Please see the final section below for information on proxies and certificates.\r\n\r\n```\r\n[url]\r\npath=\r\n\r\n[credentials]\r\nusername=YourID\r\npassword=YourPwd\r\n\r\n[proxies]\r\nproxies=\r\n\r\n[cert]\r\nsslVerify=\r\n\r\n[app]\r\ntimeout=  \r\n```\r\n\r\n\r\n# Getting started\r\n\r\nFirst of all we need to download the package:\r\n```\r\npip install DatastreamPy\r\n```\r\n\r\nThen we just import the library and refer to the following sections demonstrating usage:\r\n```\r\nimport DatastreamPy as dsweb\r\n```\r\n\r\n\r\n# Logging on with your credentials\r\n\r\nIn order to access Datastream content, you need to logon with your Datastream credentials. Each of the modules can load the credentials from a configuration file, or you can\r\nsupply the credentials directly in the constructor:\r\n\r\n```\r\n# loading credentials from a config file\r\nds = dsweb.DataClient('Config.ini')\r\n\r\n# loading credentials directly into the constructor\r\nds = dsweb.DataClient(None, 'YourID', 'YourPwd')\r\n```\r\n\r\nFor the configuration file option you can specify your credentials with the following configuration section:\r\n```\r\n[credentials]\r\n# Replace YourID and YourPwd values with your specific Datastream credentials.\r\nusername=YourID\r\npassword=YourPwd\r\n```\r\n\r\n\r\n# Basic timeseries and static data retrieval\r\n\r\nTo access timeseries or static data you use the DataClient object.\r\n\r\nA sample timeseries request takes the form:\r\n\r\n```\r\nds = dsweb.DataClient('Config.ini')\r\n\r\nstart_date = '2020-01-01'\r\nend_date = '2022-12-31'\r\n\r\n# Retrieve and print out some timeseries data for Apple and Microsoft\r\nhistory = ds.get_data(tickers = '@AAPL,@MSFT', fields = ['P', 'VO', 'RI'],\\\r\n                     kind = 1, start = start_date, end = end_date, freq = 'M')\r\nhistory.index = pd.date_range(start_date, end_date, freq = 'M')\r\nprint (history)\r\n```\r\n\r\nA sample static data request takes the form:\r\n\r\n```\r\nstaticdata = ds.get_data(tickers = '@AAPL,@MSFT', fields = ['NAME', 'ISIN', 'BDATE'], kind = 0)\r\nprint(staticdata)\r\n```\r\n\r\n\r\n# Managing custom timeseries items\r\n\r\nDatastream permits users to create and manage custom items. One of these types is custom timeseries data. Clients can upload\r\ntheir own timeseries data to Datastream’s central systems. These can then be used in combination with Datastream maintained\r\nseries in charts and data requests with the full power of the Datastream expressions language.\r\n\r\n```\r\nimport DatastreamPy as dsweb\r\nimport pandas as pd\r\n# We import random only to generate some test data \r\nimport random\r\n\r\n# create your client\r\ntimeseriesClient = dsweb.TimeseriesClient(None, 'YourID', 'YourPwd')\r\n\r\n# Note Timeseries IDs must be 8 uppercase alphanumeric characters in length and start with TS. e.g. TSZZZ001\r\ntestID = 'TSZZZ001'\r\n\r\n# let us create a data series with quarterly values between 2016-01-01 and 2022-04-01\r\nstartDate = date(2016, 1, 1)\r\nendDate = date(2022, 4, 1)\r\nfreq = dsweb.DSUserObjectFrequency.Quarterly\r\n\r\n# First step is to retrieve the list of supported dates for the above period\r\ndateRangeResp = timeseriesClient.GetTimeseriesDateRange(startDate, endDate, freq)\r\nif dateRangeResp:\r\n    if dateRangeResp.ResponseStatus == dsweb.DSUserObjectResponseStatus.UserObjectSuccess and dateRangeResp.Dates != None:\r\n        # You would normally use the returned supported dates to match up with dates in your data source\r\n        # Here we will just create some random data based on the number of returned dates\r\n        random.seed()\r\n        values = [(random.randint(1000, 20000) / 100) for k in range(0, len(dateRangeResp.Dates))]\r\n\r\n        # Construct our timeseries object with the ID, start and end dates, frequency and list of datapoints\r\n        testTs = dsweb.DSTimeSeriesRequestObject(testID, startDate, endDate, freq, values)\r\n\r\n        # Set any other optional properties directly\r\n        testTs.DisplayName = 'My first test timeseries' # set to the same as the ID in the response by default.\r\n        testTs.DecimalPlaces = 2 # we created our array of values with 2 decimal places. You can specify 0 to 8 decimal places.\r\n        testTs.Units = \"Billions\"  # Leave units blank or set with any custom text (max 12 chars).\r\n        # when requested by users in data retrieval, you can specify the quarterly dates to be returned as start, middle or end of \r\n        # the selected period (frequency). Here we want the quarterly data to be mid period (15th of middle month)\r\n        testTs.DateAlignment = dsweb.DSTimeSeriesDateAlignment.MidPeriod \r\n\r\n        # and create the new item with the overWrite option set to perfrom an update if the timeseries already exists.\r\n        tsResponse = timeseriesClient.CreateItem(testTs, overWrite = True)\r\n\r\n        # Any request dealing with a single user created item returns a DSUserObjectResponse.\r\n        # This has ResponseStatus property that indicates success or failure\r\n        if tsResponse.ResponseStatus != dsweb.DSUserObjectResponseStatus.UserObjectSuccess:\r\n            print('Request failed for timeseries with error ' + tsResponse.ResponseStatus.name + ': ' + tsResponse.ErrorMessage, end='\\n\\n')\r\n        elif tsResponse.UserObject != None:  # The timeseries item won't be returned if you set SkipItem true in CreateItem or UpdateItem\r\n            # Here we simply display the timeseries data using a dataframe.\r\n            tsItem = tsResponse.UserObject\r\n            names = ['Id', 'Desc', 'LastModified', 'StartDate', 'EndDate', 'Frequency', 'NoOfValues']\r\n            coldata = [tsItem.Id, tsItem.Description, tsItem.LastModified.strftime(\"%Y-%m-%d\"), \r\n                        tsItem.DateInfo.StartDate.strftime(\"%Y-%m-%d\"), tsItem.DateInfo.EndDate.strftime(\"%Y-%m-%d\"),\r\n                        tsItem.DateInfo.Frequency.name, tsItem.DateRange.ValuesCount]\r\n            df = pd.DataFrame(coldata, index=names)\r\n```\r\n\r\n\r\nYou can also obtain summary details for all the timeseries you currently have or retrieve the full details for a specified item. The class also\r\nsupports methods that allow you to modify or delete a given timeseries:\r\n\r\n```\r\n# list all the custom timeseries you already own\r\nitemsResp = timeseriesClient.GetAllItems()\r\n# Returns a DSUserObjectGetAllResponse which has ResponseStatus property that indicates success or failure for the query\r\nif itemsResp:\r\n    if itemsResp.ResponseStatus != dsweb.DSUserObjectResponseStatus.UserObjectSuccess:\r\n        # Your Datastream Id might not be permissioned for managing user created items on this API\r\n        print('GetAllItems failed with error ' + itemsResp.ResponseStatus.name + ': ' + itemsResp.ErrorMessage, end='\\n\\n')\r\n    elif itemsResp.UserObjectsCount == 0 or itemsResp.UserObjects == None:\r\n        print('GetAllItems returned zero timeseries items.', end='\\n\\n')\r\n    else:\r\n        \"\"\"You do have access to some timeseries.\r\n        # Here we just put the timeseries details into a dataframe and list them\r\n        print('{}{}{}'.format('GetAllItems returned ', itemsResp.UserObjectsCount, ' timeseries items.'))\r\n        data  = []\r\n        colnames = ['Id', 'Start', 'End', 'Freq', 'DPs']\r\n        for tsItem in itemsResp.UserObjects:\r\n            if tsItem:\r\n                rowdata = [tsItem.Id, tsItem.DateInfo.StartDate.strftime(\"%Y-%m-%d\"), tsItem.DateInfo.EndDate.strftime(\"%Y-%m-%d\"),\r\n                           tsItem.DateInfo.Frequency.name, tsItem.DateRange.ValuesCount]\r\n                data.append(rowdata)\r\n        df = pd.DataFrame(data, columns=colnames)\r\n        print(df, end='\\n\\n')\r\n\r\n\r\n# To retrieve the full details of a specific timeseries use the GetItem method\r\ntsResponse = timeseriesClient.GetItem(testID)\r\nif tsResponse.ResponseStatus != dsweb.DSUserObjectResponseStatus.UserObjectSuccess:\r\n    print('Request failed for timeseries with error ' + tsResponse.ResponseStatus.name + ': ' + tsResponse.ErrorMessage, end='\\n\\n')\r\nelif tsResponse.UserObject != None:  # The timeseries item won't be returned if you set SkipItem true in CreateItem or UpdateItem\r\n    # Here we simply display the timeseries data using a dataframe.\r\n    tsItem = tsResponse.UserObject\r\n    names = ['Id', 'Desc', 'LastModified', 'StartDate', 'EndDate', 'Frequency', 'NoOfValues']\r\n    coldata = [tsItem.Id, tsItem.Description, tsItem.LastModified.strftime(\"%Y-%m-%d\"), \r\n                tsItem.DateInfo.StartDate.strftime(\"%Y-%m-%d\"), tsItem.DateInfo.EndDate.strftime(\"%Y-%m-%d\"),\r\n                tsItem.DateInfo.Frequency.name, tsItem.DateRange.ValuesCount]\r\n    df = pd.DataFrame(coldata, index=names)\r\n\r\n# updating an item takes the same parameters as CreateItem. See how we construct testTs above\r\ntsResponse = timeseriesClient.UpdateItem(testTs)\r\n\r\n# And we can delete the item using the test ID we defined in the CreateItem step\r\ndelResp = timeseriesClient.DeleteItem(testID)\r\n```\r\n\r\n\r\n\r\n# Creating custom economic filters\r\n\r\nDatastream provides access to over 19 million economic series. With coverage of this extent, it can be difficult to prioritise which\r\nregion, country, sector or industry to analyse and investigate. With this in mind, clients that access the full Datatstream Web Service\r\ncan now poll for the latest changes and corrections to any of the economic series.\r\n\r\nEven with polling for changes and corrections, the large number of economic series supported can produce a large number of updates to\r\nprocess each day. To reduce the number of updates, Datastream provides a global filter, DATASTREAM_KEYIND_GLOBAL, that comprises the \r\n25K most prominent series. Querying for updates using this filter can significantly reduce the number of updates reported.\r\n\r\nClients can now also create their own custom filters comprising up to 100K series and use these to query for changes and corrections.\r\nThis section demonstrates using the DatastreamPy package to create and manage custom filters.\r\n\r\nFirst of all let us see how to query for a list of economic items that have updated since a given start date. Then we will demonstrate\r\nusing the built in filter DATASTREAM_KEYIND_GLOBAL to restrict the number of updates to a specified list of economic series.\r\n\r\nPolling for recent changes requires using a starting sequence ID and retrieving up to 10K updates with each polling request. As we process\r\neach response, we retrieve in the response the next sequence ID to request in the chain of updates until we are instructed that there\r\nare no more updates. We would then use the returned final sequence ID to poll every 10 minutes until we receive a response with new updates.\r\n\r\n```\r\nimport DatastreamPy as dsweb\r\nimport pandas as pd\r\n\r\n# Try creating the client by replacing 'YourID' and 'YourPwd' with your own credentials.\r\neconFilterClient = EconomicFilters(None, 'YourID', 'YourPwd')\r\n\r\n# We'll start searching for any changes beginning 3 weeks ago (you can go back a maximum of 28 days)\r\n# NB: Setting the timestamp to None will set the start date at 00:00 hours on the previous weekday from now\r\nupdatesResp = econFilterClient.GetEconomicChanges(datetime.today() - timedelta(days=21))\r\n# this should tell us the start sequence ID for updates from the given start datetime and how many updates we have pending\r\nsequenceId = 0 # placeholder which we will update and use later in the demo\r\nif updatesResp:\r\n    if updatesResp.ResponseStatus != dsweb.DSFilterResponseStatus.FilterSuccess:\r\n        # Any filter request errors, such as invalid filter, not being explicity permissioned to use custom economic filters, etc.\r\n        print('GetEconomicChanges failed with error ' + updatesResp.ResponseStatus.name + ': ' + updatesResp.ErrorMessage)\r\n    else:\r\n        sequenceId = updatesResp.NextSequenceId\r\n        # we'll now use this starting sequence in the following test cells.\r\n        updatesResp = econFilterClient.GetEconomicChanges(None, sequenceId)\r\n        if updatesResp:\r\n            if updatesResp.ResponseStatus != dsweb.DSFilterResponseStatus.FilterSuccess:\r\n                print('GetEconomicChanges failed with error ' + updatesResp.ResponseStatus.name + ': ' + updatesResp.ErrorMessage)\r\n            else:\r\n                if updatesResp.Updates and updatesResp.UpdatesCount > 0:\r\n                    # You have some updates; process them and retrieve the NextSequenceID for retrieving any subsequent updates.\r\n                    print ('You have {:,} new updates:'.format(updatesResp.UpdatesCount))\r\n                    updates = [[update.Series, update.Frequency.name, update.Updated.strftime('%Y-%m-%d %H:%M:%S')] for update in updatesResp.Updates]\r\n                    df = pd.DataFrame(data=updates, columns=['Series', 'Frequency', 'Updated'])\r\n                    print(df, end='\\n\\n')\r\n                if updatesResp.UpdatesPending:\r\n                    print ('You still have {:,} updates pending starting from new sequence {}.'.format(updatesResp.PendingCount, updatesResp.NextSequenceId))\r\n                else:\r\n                    print ('You have no more updates pending. Use the new sequence {} to begin polling for future updates.'.format(updatesResp.NextSequenceId))\r\n\r\n# Whilst updatesResp.UpdatesPending is True you would retrieve the next request sequence from updatesResp.NextSequenceId and request the next block of updates.\r\n# You would continue walking through the chain until you receive the final chain with updatesResp.UpdatesPending returning False\r\n# At this point the value in updatesResp.NextSequenceId will contain the ID for the next update that occurs. You then use this ID in periodic polls\r\n# (minimum every 10 minutes) to wait for new updates to be notified.\r\n```\r\n\r\nIn the previous example, where we started searching for updates starting from 3 weeks ago, you will find you have a large chain of updates to query\r\nfor in order to process the updates across the entire universe of +19 million series. \r\n\r\nTo optimise this search, Datastream provides a custom filter, DATASTREAM_KEYIND_GLOBAL, which defines the most popular economic series. Using this filter drastically cuts\r\ndown the number of updates you will receive and process.\r\n\r\n```\r\nprint('Let us repeat the processing using the same starting sequence ID. This time we will use the global filter DATASTREAM_KEYIND_GLOBAL.')\r\nupdatesResp = econFilterClient.GetEconomicChanges(None, sequenceId, 'DATASTREAM_KEYIND_GLOBAL')\r\nif updatesResp:\r\n    if updatesResp.ResponseStatus != dsweb.DSFilterResponseStatus.FilterSuccess:\r\n        print('GetEconomicChanges failed with error ' + updatesResp.ResponseStatus.name + ': ' + updatesResp.ErrorMessage)\r\n    else:\r\n        if updatesResp.Updates and updatesResp.UpdatesCount > 0:\r\n            # You have some updates; process them.\r\n            print ('You have {:,} new updates:'.format(updatesResp.UpdatesCount))\r\n            updates = [[update.Series, update.Frequency.name, update.Updated.strftime('%Y-%m-%d %H:%M:%S')] for update in updatesResp.Updates]\r\n            df = pd.DataFrame(data=updates, columns=['Series', 'Frequency', 'Updated'])\r\n            print(df, end='\\n\\n')\r\n        if updatesResp.UpdatesPending:\r\n            print ('You still have {:,} updates pending starting from new sequence {}.'.format(updatesResp.PendingCount, updatesResp.NextSequenceId))\r\n        else:\r\n            print ('You have no more updates pending. Use the new sequence {} and the filter to begin polling for future updates.'.format(updatesResp.NextSequenceId))\r\n```\r\n\r\nYou can also create your own custom economic filter to specifically query for changes just against this restricted set of economic series.\r\n```\r\n# This example demonstrates how to create a new filter.  We will define this filter with ID MyTempTestFilter\r\ndemoId = 'MyTempTestFilter'\r\n\r\n# Let us create the filter. We'll create it with 10 valid constituents but also include two invalid items, BADINST1 and \r\n# BADINSTFMT, to also demonstrate how the server will reject invalid or unsupported items. BADINST1 has valid syntax but is not a \r\n# valid series. BADINSTFMT is not the correct economic series format (7 to 9 chars only).\r\n\r\n#  NB: These are 10 random series chosen because they update frequently.\r\ninitialConstituents = ['UKEPUPO', 'USEPUPO', 'USEPUEQ', 'IDTVALS', 'IDTVOLS', 'IDTVADS', \r\n                       'IDTVALP', 'IDTVOLP', 'IDTVADP', 'IDTVAFP', 'BADINST1', 'BADINSTFMT']\r\n\r\n# we construct DSEconomicsFilter with our test ID MyTempTestFilter, assign the constituents, set the description and call CreateFilter\r\nmyFilter = DSEconomicsFilter()\r\nmyFilter.FilterId = demoId\r\n\r\nmyFilter.Constituents = initialConstituents\r\nmyFilter.Description = 'MyTempTestFilter for testing.'\r\n    \r\nprint('Creating private filter ' + demoId + '...')\r\nfilterResp = econFilterClient.CreateFilter(myFilter)\r\nif filterResp:\r\n    # Any request dealing with a single filter returns a DSEconomicsFilterResponse.\r\n    # This has ResponseStatus property that indicates success or failure\r\n    if filterResp.ResponseStatus != dsweb.DSFilterResponseStatus.FilterSuccess:\r\n        print('Request failed for filter ' + filterName + ' with error ' + filterResp.ResponseStatus.name + ': ' + filterResp.ErrorMessage, end='\\n\\n')\r\n    elif filterResp.Filter != None: #display it\r\n        filter = filterResp.Filter\r\n        names = ['FilterId', 'OwnerId', 'Shared?', 'LastModified', 'Description', 'No. of Constituents']\r\n        data = [filter.FilterId, filter.OwnerId, 'Yes' if bool(filter.Shared) else 'No', \r\n                filter.LastModified.strftime('%Y-%m-%d %H:%M:%S'), filter.Description, filter.ConstituentsCount]\r\n        df = pd.DataFrame(data, index=names)\r\n        print(df)\r\n\r\n        print('The filter contains the following constituents:')\r\n        df = pd.DataFrame(filter.Constituents)\r\n        print(df, end='\\n\\n')\r\n            \r\n        if filterResp.ItemErrors and len(filterResp.ItemErrors) > 0:\r\n            print('The service did not add the following items as they are invalid or are not supported:')\r\n            df = pd.DataFrame(filterResp.ItemErrors)\r\n            print(df, end='\\n\\n')\r\n```\r\n\r\nYou can then use your new filter in any queries for new updates:\r\n```\r\nupdatesResp = econFilterClient.GetEconomicChanges(None, sequenceId, 'MyTempTestFilter')\r\n# see the initial GetEconomicChanges example for how to process the result\r\n```\r\n\r\nThe EconomicsFilter object also supports the following methods:\r\n* GetAllFilters - returns a summary list of all filters owned by you and/or the globally available filters.\r\n* GetFilter - returns the full details, including constituents, for a specified filter.\r\n* UpdateFilter - allows you to append or remove specified constituent series or replace all the constituents.\r\n* DeleteFilter - allows you to delete one of your filters.\r\n\r\n\r\n\r\n# Error handling\r\n\r\nThe DatastreamPy package makes web API queries against our servers. This can result in network errors or authentication errors if you\r\nare not authorised to use the service.\r\n\r\nDSUserObjectFault exceptions are thrown for any non-network errors from the API. These are returned for the following reasons:\r\n* Invalid credentials\r\n* Empty credentials\r\n* Access blocked due to missuse of the service (for filter requests after credentials validation).\r\n\r\nAny general network errors such as firewall issues, proxy issues, general connectivity issues, etc. will throw an Exception object.\r\nThis will typically be returned from the sessions.py module directly, or an exception will be thrown using the Response.raise_for_status()\r\nshould the returned response not be processed correctly.\r\n\r\n\r\n```\r\ntry:\r\n    # Try creating the client by replacing 'YourID' and 'YourPwd' with your own credentials.\r\n    econFilterClient = dsweb.EconomicFilters(None. 'YourId', 'YourPwd')\r\n    print('Successfully created the EconomicFilters client.', end='\\n\\n')\r\n\r\nexcept DSUserObjectFault as dsFault:\r\n    print('EconomicFilters() failed returning a DSUserObjectFault exception:')\r\n    print(dsFault)\r\nexcept Exception as exp:\r\n    print('A network error occurred.')\r\n    print(exp)\r\n```\r\n\r\n\r\nFor requests against the TimeseriesClient or EconomicFilters client objects (e.g. GetAllItems), the response object contains either a\r\nDSUserObjectResponseStatus or DSFilterResponseStatus object in the ResponseStatus property. If the status is not UserObjectSuccess or \r\nFilterSuccess, then this specifies a logical failure with the request on our server. In this event, the ErrorMessage property will\r\nspecify the reason for the error.\r\n\r\nFor DSUserObjectResponseStatus the following status values exist:\r\n* UserObjectSuccess: The request succeeded and the response object's UserObject(s) property should contain the (updated) object (except for DeleteItem method).\r\n* UserObjectPermissions: Users need to be specifically permissioned to create custom objects. This flag is set if you are not currently permissioned.\r\n* UserObjectNotPresent: Returned if the requested ID does not exist.\r\n* UserObjectFormatError: Returned if your request object is not in the correct format.\r\n* UserObjectTypeError: Returned if your supplied object is not the same as the type specified.\r\n* UserObjectError:  The generic error flag. This will be set for any error not specified above. (e.g. object not present, etc.)\r\n\r\nFor DSFilterResponseStatus the following status values exist:\r\n* FilterSuccess: The request succeeded and the response object's Filter property should contain the (updated) filter (except for DeleteFilter method).\r\n* FilterPermissions: Users need to be specifically permissioned to create custom filters. This flag is set if you are not currently permissioned.\r\n* FilterNotPresent: Returned if the requested ID does not exist.\r\n* FilterFormatError: Returned if your request filter ID is not in the correct format, or if you try and modify a Datastream global filter (ID begins DATASTREAM*).\r\n* FilterSizeError: Returned if your call to CreateFilter or ModifyFilter contains a list with zero or in excess of the 100K constituents.\r\n* FilterConstituentsError: Returned if your supplied filter constituent list (on CreateFilter) contains no valid economic series. The filter won't be created.\r\n* FilterError:  The generic error flag. This will be set for any error not specified above. (e.g. Requested filter ID is not present)\r\n\r\n\r\n# Proxies and certificates\r\n\r\nThe module uses the requests package to make the web api queries using a sessions object internally:\r\n```\r\nhttpResponse = self._reqSession.post(reqUrl, json = jsonRequest,  proxies = self._proxies, verify = self._certfiles, cert = self._sslCert, timeout = self._timeout)\r\n```\r\n\r\nYou can provide the proxy and certificate details in the constructor of each client object:\r\n\r\n```\r\nx = EconomicFilters(None, username = 'YourID', password = 'YourPwd', proxies = x, sslVerify = y, sslCert = z)\r\n```\r\n\r\nAlternatively, the proxy and the root certificates for verification can be set in the configuration file:\r\n\r\n```\r\n[proxies]\r\n# of the form: { 'http' : proxyHttpAddress,  'https' : proxyHttpsAddress }\r\nproxies=\r\n\r\n[cert]\r\n# option to supply a specific python requests verify option. \r\nsslVerify=\r\n\r\n[app]\r\ntimeout=  \r\n```\r\n\r\nFor specifying the proxy see the verify and cert properties on the session post method, see [this link](https://docs.python-requests.org/en/latest/user/advanced/).\r\n\r\nIf you do not override a root certificates option for the verify parameter, the code will use the ssl package on Windows platforms\r\nto import the root certificates into a temporary file tempCertFile.pem and uses that as the verify parameter. For non-Windows\r\nplatforms, the package will use the results of the requests.certs.where() method to set the verify parameter. \r\n\r\n","description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":null,"keywords":null,"license":"Apache Software License (http://www.apache.org/licenses/LICENSE-2.0)","license_expression":null,"license_files":null,"maintainer":null,"maintainer_email":null,"name":"DatastreamPy","package_url":"https://pypi.org/project/DatastreamPy/","platform":null,"project_url":"https://pypi.org/project/DatastreamPy/","project_urls":null,"provides_extra":null,"release_url":"https://pypi.org/project/DatastreamPy/2.0.30/","requires_dist":["pandas","requests"],"requires_python":">=3","summary":"Python package for Datastream Web Services API","version":"2.0.30","yanked":false,"yanked_reason":null},"last_serial":23427432,"releases":{"1.0.10":[{"comment_text":"","digests":{"blake2b_256":"92b1441261ba2946b9812769b76b51550f4e8200469ac5d4da3c93deb21b1b76","md5":"1be9e07a3a5c85e6a2a9e8cefc305c1b","sha256":"7cb7a054c9ccf41a03cc28fb8e5d9e9d1f4653c1a4d1a170d2a294c7acec6939"},"downloads":-1,"filename":"DatastreamPy-1.0.10-py3-none-any.whl","has_sig":false,"md5_digest":"1be9e07a3a5c85e6a2a9e8cefc305c1b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":7996,"upload_time":"2021-12-21T11:02:21","upload_time_iso_8601":"2021-12-21T11:02:21.786768Z","url":"https://files.pythonhosted.org/packages/92/b1/441261ba2946b9812769b76b51550f4e8200469ac5d4da3c93deb21b1b76/DatastreamPy-1.0.10-py3-none-any.whl","yanked":true,"yanked_reason":"init.py file not included in building package"}],"1.0.12":[{"comment_text":"","digests":{"blake2b_256":"e85ec46d349873b136974c7d0242fddcc5310c41810ffb6f5decded3e5915154","md5":"4f762080e6f4e74168b25c78bb6775fe","sha256":"ad3f4673814dbe87a932bc0a5efb0ef4f5f8836f433b873e3e8919dddcf05940"},"downloads":-1,"filename":"DatastreamPy-1.0.12-py3-none-any.whl","has_sig":false,"md5_digest":"4f762080e6f4e74168b25c78bb6775fe","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":7993,"upload_time":"2021-12-21T13:02:01","upload_time_iso_8601":"2021-12-21T13:02:01.382474Z","url":"https://files.pythonhosted.org/packages/e8/5e/c46d349873b136974c7d0242fddcc5310c41810ffb6f5decded3e5915154/DatastreamPy-1.0.12-py3-none-any.whl","yanked":false,"yanked_reason":null}],"2.0.21":[{"comment_text":"","digests":{"blake2b_256":"e092d1487e7c6398683a7413c80e9f808c077f9d1adf7662c5ca1015d3c4f876","md5":"5c1f1eb103f5ac7582ce9e62a12d36c0","sha256":"36980450920e79d5e81d4fd9992df65606c434cf906fcdcb36f9d5e0d7e8cfb8"},"downloads":-1,"filename":"DatastreamPy-2.0.21-py3-none-any.whl","has_sig":false,"md5_digest":"5c1f1eb103f5ac7582ce9e62a12d36c0","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51198,"upload_time":"2024-02-13T09:12:44","upload_time_iso_8601":"2024-02-13T09:12:44.793848Z","url":"https://files.pythonhosted.org/packages/e0/92/d1487e7c6398683a7413c80e9f808c077f9d1adf7662c5ca1015d3c4f876/DatastreamPy-2.0.21-py3-none-any.whl","yanked":false,"yanked_reason":null}],"2.0.24":[{"comment_text":"","digests":{"blake2b_256":"9fb6ba2549b8b579c16e410f666543336b8ed1fd7a7fa5433cc1640464cb5849","md5":"d2a235f47fe1e76157c05a738c5e4bf1","sha256":"9e264d5b60414fed59bdc8deb72b0b0de9b95e314e66a38230bd6c017d264b1b"},"downloads":-1,"filename":"DatastreamPy-2.0.24-py3-none-any.whl","has_sig":false,"md5_digest":"d2a235f47fe1e76157c05a738c5e4bf1","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51260,"upload_time":"2024-05-17T15:36:08","upload_time_iso_8601":"2024-05-17T15:36:08.071341Z","url":"https://files.pythonhosted.org/packages/9f/b6/ba2549b8b579c16e410f666543336b8ed1fd7a7fa5433cc1640464cb5849/DatastreamPy-2.0.24-py3-none-any.whl","yanked":true,"yanked_reason":"please download DatstreamPy 2.0.28"}],"2.0.25":[{"comment_text":"","digests":{"blake2b_256":"e4dcaa081c72d4cf42091e16d83ef356cffe896b594effe52ac899bcf4a568a9","md5":"8cfd6d0e0cb51a1d47ec3bc775f9de68","sha256":"afb3afe8b6129b2a9f63b611f42459bf2b1493fd3f23bc2863bd656aad94786b"},"downloads":-1,"filename":"DatastreamPy-2.0.25-py3-none-any.whl","has_sig":false,"md5_digest":"8cfd6d0e0cb51a1d47ec3bc775f9de68","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51261,"upload_time":"2024-05-17T17:18:20","upload_time_iso_8601":"2024-05-17T17:18:20.070518Z","url":"https://files.pythonhosted.org/packages/e4/dc/aa081c72d4cf42091e16d83ef356cffe896b594effe52ac899bcf4a568a9/DatastreamPy-2.0.25-py3-none-any.whl","yanked":true,"yanked_reason":"Please download DatastreamPy 2.0.28"}],"2.0.28":[{"comment_text":"","digests":{"blake2b_256":"c06d5ecec19871b1efd89b5460f81dd3ef13cdf4cddafd0e74043d17c361d003","md5":"2ce377586e7f9e184266bc11b08e427a","sha256":"9bfea2132e59a40404cb755aad0d47be361178a2f906329440dc654ceff92176"},"downloads":-1,"filename":"DatastreamPy-2.0.28-py3-none-any.whl","has_sig":false,"md5_digest":"2ce377586e7f9e184266bc11b08e427a","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51262,"upload_time":"2024-05-21T09:48:06","upload_time_iso_8601":"2024-05-21T09:48:06.474300Z","url":"https://files.pythonhosted.org/packages/c0/6d/5ecec19871b1efd89b5460f81dd3ef13cdf4cddafd0e74043d17c361d003/DatastreamPy-2.0.28-py3-none-any.whl","yanked":false,"yanked_reason":null}],"2.0.30":[{"comment_text":"","digests":{"blake2b_256":"7871f6f751ff0078e18448307d3ac0b4a7b53f243d75febb3244acfdcff4aa4e","md5":"91235639ac443b327b7dd1954a5ee2d0","sha256":"d2c331266dd0120036df76fbf3af7dca9f4d30366093c2e0f6f2b00c3c26972b"},"downloads":-1,"filename":"DatastreamPy-2.0.30-py3-none-any.whl","has_sig":false,"md5_digest":"91235639ac443b327b7dd1954a5ee2d0","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51333,"upload_time":"2024-05-29T09:31:56","upload_time_iso_8601":"2024-05-29T09:31:56.443864Z","url":"https://files.pythonhosted.org/packages/78/71/f6f751ff0078e18448307d3ac0b4a7b53f243d75febb3244acfdcff4aa4e/DatastreamPy-2.0.30-py3-none-any.whl","yanked":false,"yanked_reason":null}]},"urls":[{"comment_text":"","digests":{"blake2b_256":"7871f6f751ff0078e18448307d3ac0b4a7b53f243d75febb3244acfdcff4aa4e","md5":"91235639ac443b327b7dd1954a5ee2d0","sha256":"d2c331266dd0120036df76fbf3af7dca9f4d30366093c2e0f6f2b00c3c26972b"},"downloads":-1,"filename":"DatastreamPy-2.0.30-py3-none-any.whl","has_sig":false,"md5_digest":"91235639ac443b327b7dd1954a5ee2d0","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3","size":51333,"upload_time":"2024-05-29T09:31:56","upload_time_iso_8601":"2024-05-29T09:31:56.443864Z","url":"https://files.pythonhosted.org/packages/78/71/f6f751ff0078e18448307d3ac0b4a7b53f243d75febb3244acfdcff4aa4e/DatastreamPy-2.0.30-py3-none-any.whl","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}
