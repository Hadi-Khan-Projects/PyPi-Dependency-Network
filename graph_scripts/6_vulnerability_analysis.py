import networkx as nx
import csv
import matplotlib.pyplot as plt
from packaging.requirements import Requirement
from packaging.specifiers import SpecifierSet
from packaging.version import Version
import numpy as np
import json
import os

GRAPHML_FILE = "graph/pypi_dependencies.graphml"
DEPENDENCIES_CSV = "data/pypi_package_dependencies_with_vulnerabilities.csv"
METADATA_FOLDER = "data/package_metadata"


def load_reversed_graph(graphml_file):
    G = nx.read_graphml(graphml_file)
    G_rev = G.reverse(copy=True)
    return G_rev

# 1) Build package->dependencies map from CSV
def parse_dependency(raw_dep):
    """Given a raw dependency string (PEP 508 style), return (dep_name, specifier_str)."""
    raw_dep = raw_dep.strip()
    if not raw_dep:
        return None, None
    
    try:
        req = Requirement(raw_dep)
        dep_name = req.name
        spec_str = str(req.specifier)
        return dep_name, spec_str
    except:  # noqa: E722
        return None, None

def load_package_dependencies(csv_path):
    """
    Returns { package: [(dep_name, spec_str), ...], ... }
    by parsing the 'dependencies_raw' column in the CSV.
    """
    package_deps_map = {}
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            pkg = row["project"]
            deps_raw = row["dependencies_raw"]
            dep_entries = []
            
            if deps_raw.strip():
                raw_list = [r.strip() for r in deps_raw.split(";")]
                for raw_entry in raw_list:
                    if raw_entry:
                        dname, dspec = parse_dependency(raw_entry)
                        if dname:
                            dep_entries.append((dname, dspec))
            
            package_deps_map[pkg] = dep_entries
    return package_deps_map

# 2) Read latest version of each package
def load_latest_versions(metadata_folder):
    """
    Returns { package_name: version_string }
    """
    latest_versions = {}
    for fname in os.listdir(metadata_folder):
        if fname.endswith(".json"):
            pkg = fname[:-5]  # remove ".json"
            fpath = os.path.join(metadata_folder, fname)
            try:
                with open(fpath, "r", encoding="utf-8") as jf:
                    data = json.load(jf)
                version_str = data.get("info", {}).get("version", "")
                if version_str:
                    latest_versions[pkg] = version_str
            except:  # noqa: E722
                pass
    return latest_versions

# 3) Infectious spread simulation
def simulate_vulnerability_spread(
    G_reversed, 
    package_deps_map, 
    latest_versions, 
    start_package
):
    infected = set()
    stack = [start_package]
    
    # get version of the start_package we consider "vulnerable" elif default 0.0.0
    start_ver_str = latest_versions.get(start_package, "0.0.0")
    start_ver = Version(str(start_ver_str))

    while stack:
        current = stack.pop()
        if current in infected:
            continue
        infected.add(current)
        
        for next_pkg in G_reversed[current]:
            dep_list = package_deps_map.get(next_pkg, [])
            for (dep_name, spec_str) in dep_list:
                if dep_name == current and spec_str:
                    try:
                        spec_set = SpecifierSet(spec_str)
                        if start_ver in spec_set:
                            stack.append(next_pkg)
                            break
                    except:  # noqa: E722
                        pass
    return infected

# 4) Run infection simulation for every package
def main():
    G_rev = load_reversed_graph(GRAPHML_FILE)
    
    # package dependencies
    package_deps_map = load_package_dependencies(DEPENDENCIES_CSV)
    
    # get latest versions
    latest_versions = load_latest_versions(METADATA_FOLDER)
    
    #  list of all packages
    all_packages = []
    with open(DEPENDENCIES_CSV, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            all_packages.append(row["project"])
    
    # For each of the 8000 packages, do the infection simulation
    infection_sizes = {}
    infected_lists = {}
    
    for i, pkg in enumerate(all_packages):
        infected = simulate_vulnerability_spread(
            G_rev,
            package_deps_map,
            latest_versions,
            pkg
        )
        infection_sizes[pkg] = len(infected)
        infected_lists[pkg] = infected
        
        if (i + 1) % 100 == 0:
            print(f"Simulated {i+1} / {len(all_packages)} packages...")
    
    counts = list(infection_sizes.values())
    plt.figure(figsize=(8, 5))
    plt.hist(counts, bins=50, edgecolor="black", log=True)
    plt.title("Logarithmic Distribution of Infection Sizes for Each 'Patient Zero'")
    plt.xlabel("Number of infected packages")
    plt.ylabel("Count (log scale)")
    plt.tight_layout()
    plt.savefig("infection_size_distribution_log.png")
    print("Saved logarithmic infection size distribution as infection_size_distribution_log.png.")
    plt.close()

    counts_sorted = np.sort(counts)
    cdf = np.cumsum(counts_sorted) / sum(counts_sorted)

    plt.figure(figsize=(8, 5))
    plt.plot(counts_sorted, cdf, marker=".", linestyle="none")
    plt.title("Cumulative Distribution Function of Infection Sizes")
    plt.xlabel("Number of infected packages")
    plt.ylabel("Cumulative fraction")
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("infection_size_cdf.png")
    print("Saved CDF of infection size as infection_size_cdf.png.")
    plt.close()

    # top packages by infection size
    sorted_by_size = sorted(infection_sizes.items(), key=lambda x: x[1], reverse=True)
    top_20 = sorted_by_size[:100]
    
    print("\nTop 100 most 'infectious' packages:")
    for rank, (pkg_name, inf_size) in enumerate(top_20, start=1):
        print(f"{rank}. {pkg_name} -> {inf_size} packages infected")
    print()

    with open("infection_results.csv", "w", encoding="utf-8", newline="") as outf:
        writer = csv.writer(outf)
        writer.writerow(["package", "infected_count", "infected_list"])
        for pkg_name in all_packages:
            writer.writerow([
                pkg_name,
                infection_sizes[pkg_name],
                ";".join(sorted(infected_lists[pkg_name]))
            ])
    print("Saved infection details to infection_results.csv.")

if __name__ == "__main__":
    main()
